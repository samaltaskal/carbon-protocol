#!/usr/bin/env python3
"""
Convert Mined Clusters to Carbon Protocol Dictionary Patterns

Reads the output from miner/discovery.py and generates YAML dictionary files
for use with the Carbon Protocol compression engine.

Usage:
    python tools/convert_mined_to_patterns.py --input mined_prompts_50k.json --output src/data/mined_patterns.yaml
"""

import argparse
import json
import re
from pathlib import Path
from datetime import datetime


def clean_token(phrase: str) -> str:
    """Convert a phrase to a valid token suffix."""
    # Uppercase, replace spaces/hyphens with underscore
    token = phrase.upper().replace(" ", "_").replace("-", "_")
    # Remove non-alphanumeric (except underscore)
    token = re.sub(r'[^A-Z0-9_]', '', token)
    # Collapse multiple underscores
    token = re.sub(r'_+', '_', token).strip('_')
    # Limit length
    return token[:50]


def categorize_cluster(representative: str, variations: list) -> str:
    """Determine the token category based on cluster content."""
    text = (representative + " " + " ".join(variations)).lower()
    
    # Coding patterns
    if any(kw in text for kw in ['python', 'script', 'function', 'code', 'program', 'java', 'node']):
        return "CODE"
    if any(kw in text for kw in ['api', 'rest', 'database', 'sql', 'table']):
        return "CODE:API"
    if any(kw in text for kw in ['error', 'debug', 'handling']):
        return "CODE:DEBUG"
    
    # Reasoning patterns
    if any(kw in text for kw in ['step step', 'reasoning', 'think', 'plan']):
        return "REASON"
    if any(kw in text for kw in ['calculate', 'compute', 'formula', 'equation']):
        return "REASON:MATH"
    
    # Writing patterns
    if any(kw in text for kw in ['rewrite', 'improve', 'correct']):
        return "EDIT"
    if any(kw in text for kw in ['summarize', 'summary']):
        return "EDIT:SUMMARIZE"
    
    # Science patterns
    if any(kw in text for kw in ['enthalpy', 'chemistry', 'reaction', 'scientific']):
        return "SCI:CHEM"
    if any(kw in text for kw in ['speed', 'distance', 'velocity', 'physics']):
        return "SCI:PHYS"
    
    # Data structures
    if any(kw in text for kw in ['binary', 'tree', 'stack', 'queue', 'push', 'pop']):
        return "DS"
    
    # Default
    return "MINED"


def convert_clusters_to_patterns(clusters: list, min_frequency=100) -> dict:
    """Convert cluster data to Carbon Protocol pattern format."""
    patterns = {}
    
    for cluster in clusters:
        freq = cluster.get("frequency", 0)
        if freq < min_frequency:
            continue
            
        representative = cluster.get("representative_phrase", "")
        variations = cluster.get("variations", [])
        
        if not representative:
            continue
        
        # Determine category
        category = categorize_cluster(representative, variations)
        
        # Create token from representative phrase
        token_suffix = clean_token(representative)
        token = f"@{category}:{token_suffix}"
        
        # Add representative phrase
        patterns[representative.lower()] = token
        
        # Add high-value variations (skip noisy ones)
        for var in variations[:10]:  # Limit variations per cluster
            var_lower = var.lower()
            if var_lower not in patterns and len(var_lower) >= 10:
                patterns[var_lower] = token
    
    return patterns


def generate_yaml(patterns: dict, source: str) -> str:
    """Generate YAML content for the patterns."""
    header = f'''# Carbon Protocol Dictionary - Mined Patterns
# Generated by: convert_mined_to_patterns.py
# Source: {source}
# Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
# 
# Format: "raw phrase": "COMPRESSED_TOKEN"
# These patterns were discovered by mining real LLM prompt datasets.

'''
    lines = [header, "patterns:\n"]
    
    for key in sorted(patterns.keys()):
        value = patterns[key]
        escaped_key = key.replace('"', '\\"')
        lines.append(f'  "{escaped_key}": "{value}"\n')
    
    return "".join(lines)


def main():
    parser = argparse.ArgumentParser(description="Convert mined clusters to Carbon Protocol patterns")
    parser.add_argument("--input", type=str, required=True, help="Input JSON file from miner")
    parser.add_argument("--output", type=str, required=True, help="Output YAML file")
    parser.add_argument("--min-freq", type=int, default=100, help="Minimum frequency threshold")
    
    args = parser.parse_args()
    
    # Load clusters
    print(f"Loading clusters from {args.input}...")
    with open(args.input, 'r', encoding='utf-8') as f:
        clusters = json.load(f)
    
    print(f"Found {len(clusters)} clusters")
    
    # Convert to patterns
    patterns = convert_clusters_to_patterns(clusters, min_frequency=args.min_freq)
    print(f"Generated {len(patterns)} patterns (min_freq={args.min_freq})")
    
    # Generate and save YAML
    yaml_content = generate_yaml(patterns, args.input)
    
    output_path = Path(args.output)
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(yaml_content)
    
    print(f"Saved to {args.output}")


if __name__ == "__main__":
    main()
